# Span App - Interview Process

## First interview: Coding

You won‚Äôt be asked solely about what data structures exist, you need to be able to apply them to different problems and understand how they work under the hood. The following outlines some key aspects you may need knowledge of for this interview:

- Runtime and Space complexity
- Tables / Maps
- Recursion and Iterative solutions

Well-known algorithms and data structures (not necessarily be prepared to implement, but be familiar with when/how to use them, their pros and cons, time/space complexity, and so forth):

- Sorting
- Merge
- Quick
- Heap
- Linked lists
- Binary search
- Concurrency
- Dynamic Programming

  The more well versed you are with libraries and out-of-the-box features in your language of choice the better you are setting yourself up for success. Furthermore, you should be able to comfortably translate something on a whiteboard to code. You are encouraged to use the language you are most comfortable with, however If you are coming in specifically for a frontend engineer position you will be asked to use JavaScript or TypeScript to complete the problem.

<details>
  <summary>üöÄ Roadmap: Preparing for Span‚Äôs Coding Interview</summary>

1.  ‚úÖ Step 1: Strengthen Problem-Solving Foundations.

    Big-O Analysis & Complexity
    Understand Time & Space Complexity (O(1), O(log N), O(N), O(N log N), O(N¬≤))
    Learn how to analyze code runtime and identify bottlenecks.
    üìö Resources:
    Big-O Cheatsheet
    YouTube: ‚ÄúBig-O Notation‚Äù by CS Dojo / freeCodeCamp
    JavaScript/TypeScript Built-in Data Structures & Methods
    Arrays: .push(), .pop(), .shift(), .unshift(), .splice(), .slice()
    Objects & Maps: Map(), Set(), Object.keys(), Object.values()
    Strings: .split(), .join(), .substring()
    Sorting methods: sort(), localeCompare(), toSorted()
    Recursion vs Iterative approaches in JS

2.  ‚úÖ Step 2: Master Core Data Structures (5-6 days)

    1Ô∏è‚É£ Tables / Maps (Hashing)
    Understand Hash Tables (Objects, Map(), Set())
    Common problems: Two Sum, Group Anagrams, First Unique Character
    üèÜ Practice: LeetCode Easy-Medium Hash Table problems
    2Ô∏è‚É£ Sorting Algorithms
    Know when to use Merge Sort (O(N log N)), Quick Sort (O(N log N)), Heap Sort
    Understand JavaScript‚Äôs built-in Array.sort() (Timsort, O(N log N))
    Implement and compare sorting algorithms
    3Ô∏è‚É£ Linked Lists
    Difference between Singly vs Doubly Linked List
    Common problems: Reverse a Linked List, Detect a Cycle, Merge Two Sorted Lists
    üèÜ Practice: LeetCode Easy-Medium Linked List problems
    4Ô∏è‚É£ Binary Search
    Understand binary search (O(log N))
    Common problems: Find Element in Sorted Array, First & Last Position, Rotated Array
    üèÜ Practice: LeetCode Easy-Medium Binary Search problems
    5Ô∏è‚É£ Concurrency (JS Event Loop)
    Understand Promises, Async/Await, Web Workers
    JavaScript Event Loop & Microtask Queue
    Solve Concurrency-Based Problems (Rate Limiter, Parallel Promises)
    6Ô∏è‚É£ Dynamic Programming (DP)
    Identify Overlapping Subproblems & Optimal Substructure
    Common DP Patterns: Fibonacci, Climbing Stairs, Knapsack, Longest Common Subsequence
    Bottom-Up vs Top-Down Approach

3.  ‚úÖ Step 3: Develop Strong Recursion & Iterative Skills

    Practice converting recursive solutions to iterative solutions (and vice versa).
    Master tree traversal (DFS & BFS).
    Focus on Divide & Conquer (Merge Sort, Quick Sort).
    üèÜ Practice: LeetCode Medium-Hard Recursion problems.

4.  ‚úÖ Step 4: Solve Well-Known Algorithms & Problems

    Two Pointers & Sliding Window: Find pairs, substrings, or subarrays efficiently.
    Graph Traversal (DFS, BFS): Connected Components, Shortest Paths.
    Heap (Priority Queue): Find k-largest/smallest elements.
    Top-K Patterns: Sorting + Heap-based solutions.
    Greedy Algorithms: Interval Scheduling, Activity Selection.

üèÜ Practice Set:
LeetCode: "Top 75" list
NeetCode.io roadmap
JS-specific Problems on CodeSignal & CoderByte

</details>
